[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Here, I will share my knowledge and experience with the R community and provide helpful tips and resources for other R programmers.\nOn this blog, you can expect to find articles on topics such as:\n- R shiny development\n- Overviews and tutorials on specific R packages or functions\n- Tips and tricks for improving R code efficiency\n- Personal musings and reflections on my experiences as an R programmer"
  },
  {
    "objectID": "posts/the-power-of-dot-names-in-dplyr-across/index.html",
    "href": "posts/the-power-of-dot-names-in-dplyr-across/index.html",
    "title": "The power of .names in dplyr::across()",
    "section": "",
    "text": "Introduction\nMy project manager is a die-hard fan of the tidyverse. I go to the office once a week, and last Friday was one of those days.\nHe comes up to me and says:\n“Good afternoon Mwavu, you know how much I’m into the tidyverse and piping. But today, it seems, I have to break my pipeline. Come have a look.”\n\n\n\nProblem statement\n“Say I have this tibble:\n\nprem_sum <- tibble::tibble(\n  id = head(letters), \n  prem_a = seq_along(id), \n  sum_a = seq_along(id) * 2, \n  prem_b = prem_a, \n  sum_b = sum_a, \n  prem_c = prem_a, \n  sum_c = sum_a\n)\n\nprint(prem_sum)\n\n# A tibble: 6 × 7\n  id    prem_a sum_a prem_b sum_b prem_c sum_c\n  <chr>  <int> <dbl>  <int> <dbl>  <int> <dbl>\n1 a          1     2      1     2      1     2\n2 b          2     4      2     4      2     4\n3 c          3     6      3     6      3     6\n4 d          4     8      4     8      4     8\n5 e          5    10      5    10      5    10\n6 f          6    12      6    12      6    12\n\n\nI want to divide the corresponding ‘prem’ and ‘sum’ columns, ie. prem_a / sum_a, prem_b / sum_b, prem_c / sum_c etc.\nFrom that, new columns should be created with the name format of prem_sum_a, prem_sum_b, prem_sum_c etc.\nHow do I do that without having to create an intermediate object to hold the result of the calculations and then having to patch it back to the original tibble?\nIn other words, how do I not break my pipeline? Also, I have around 20 such columns.”\n\n\nHave you tried across()?\n“Yes I have but it overwrites my previous columns. Look at this:\n\nprem_sum |> \n  dplyr::mutate(\n    dplyr::across(\n      .cols = dplyr::starts_with('prem_')\n    ) / \n      dplyr::across(\n        .cols = dplyr::starts_with('sum_')\n      )\n  )\n\n# A tibble: 6 × 7\n  id    prem_a sum_a prem_b sum_b prem_c sum_c\n  <chr>  <dbl> <dbl>  <dbl> <dbl>  <dbl> <dbl>\n1 a        0.5     2    0.5     2    0.5     2\n2 b        0.5     4    0.5     4    0.5     4\n3 c        0.5     6    0.5     6    0.5     6\n4 d        0.5     8    0.5     8    0.5     8\n5 e        0.5    10    0.5    10    0.5    10\n6 f        0.5    12    0.5    12    0.5    12\n\n\nAll prem_* columns are overwritten, and I don’t want that to happen.”\n\n\nWhat about the .names argument to across()?\n“No, not yet.”\nOkay, let’s give it a shot:\n\nprem_sum |> \n  dplyr::mutate(\n    dplyr::across(\n      .cols = dplyr::starts_with('prem_'), \n      .names = 'PREMSUM_{.col}'\n    ) / \n      dplyr::across(\n        .cols = dplyr::starts_with('sum_')\n      )\n  )\n\n# A tibble: 6 × 10\n  id    prem_a sum_a prem_b sum_b prem_c sum_c PREMSUM_prem_a PREMSUM_…¹ PREMS…²\n  <chr>  <int> <dbl>  <int> <dbl>  <int> <dbl>          <dbl>      <dbl>   <dbl>\n1 a          1     2      1     2      1     2            0.5        0.5     0.5\n2 b          2     4      2     4      2     4            0.5        0.5     0.5\n3 c          3     6      3     6      3     6            0.5        0.5     0.5\n4 d          4     8      4     8      4     8            0.5        0.5     0.5\n5 e          5    10      5    10      5    10            0.5        0.5     0.5\n6 f          6    12      6    12      6    12            0.5        0.5     0.5\n# … with abbreviated variable names ¹​PREMSUM_prem_b, ²​PREMSUM_prem_c\n\n\n“Ahaa, that’s nice! I can now rename the columns starting with PREMSUM to whatever I need. I was kinda hoping for something better and straightforward though.”\nThat’s the best I can think of now.\n\n\nReally?!\nA week down the line and today I found myself messing around with across(). I remembered my PM’s question and his words “… I was kinda hoping for something better and straightforward though.”\nDoes he have to dplyr::rename()?\nFirst, let’s have a look at the documentation of .names arg in across():\n\nA glue specification that describes how to name the output columns. This can use {.col} to stand for the selected column name, and {.fn} to stand for the name of the function being applied. The default (NULL) is equivalent to “{.col}” for the single function case and “{.col}_{.fn}” for the case where a list is used for .fns.\n\nYou mean {.col} can only be used for the current column which is being computed on? Then there surely isn’t a better way.\nWait… Do me a favor and print out {.col}, just curious.\n\nprem_sum |> \n  dplyr::mutate(\n    dplyr::across(\n      .cols = dplyr::starts_with('prem_'), \n      .names = 'PREMSUM_{print(.col)}'\n    ) / \n      dplyr::across(\n        .cols = dplyr::starts_with('sum_')\n      )\n  )\n\n[1] \"prem_a\" \"prem_b\" \"prem_c\"\n\n\n# A tibble: 6 × 10\n  id    prem_a sum_a prem_b sum_b prem_c sum_c PREMSUM_prem_a PREMSUM_…¹ PREMS…²\n  <chr>  <int> <dbl>  <int> <dbl>  <int> <dbl>          <dbl>      <dbl>   <dbl>\n1 a          1     2      1     2      1     2            0.5        0.5     0.5\n2 b          2     4      2     4      2     4            0.5        0.5     0.5\n3 c          3     6      3     6      3     6            0.5        0.5     0.5\n4 d          4     8      4     8      4     8            0.5        0.5     0.5\n5 e          5    10      5    10      5    10            0.5        0.5     0.5\n6 f          6    12      6    12      6    12            0.5        0.5     0.5\n# … with abbreviated variable names ¹​PREMSUM_prem_b, ²​PREMSUM_prem_c\n\n\nWhoa!\n{.col} is a vector of all the selected column names, not just the current one.\nThat means I can manipulate the .names arg even further.\nIt can get easier.\n\n\nBetter, huh?\nLet’s start small. Say I have this vector:\n\nx <- paste0('prem_', letters[1:3])\nprint(x)\n\n[1] \"prem_a\" \"prem_b\" \"prem_c\"\n\n\nAll I need is to add ‘sum’ between ‘prem’ and the suffixes, separated by an underscore. I can use substr() for that:\n\npaste0(\n  'prem_sum', \n  substr(x = x, start = nchar('prem_'), stop = nchar(x))\n)\n\n[1] \"prem_sum_a\" \"prem_sum_b\" \"prem_sum_c\"\n\n\nCircling back, replace x with .col in substr():\n\nprem_sum |> \n  dplyr::mutate(\n    dplyr::across(\n      .cols = dplyr::starts_with('prem_'), \n      .names = \"{paste0(\n        'prem_sum', \n        substr(x = .col, start = nchar('prem_'), stop = nchar(.col))\n      )}\"\n    ) / \n      dplyr::across(\n        .cols = dplyr::starts_with('sum_')\n      )\n  )\n\n# A tibble: 6 × 10\n  id    prem_a sum_a prem_b sum_b prem_c sum_c prem_sum_a prem_sum_b prem_sum_c\n  <chr>  <int> <dbl>  <int> <dbl>  <int> <dbl>      <dbl>      <dbl>      <dbl>\n1 a          1     2      1     2      1     2        0.5        0.5        0.5\n2 b          2     4      2     4      2     4        0.5        0.5        0.5\n3 c          3     6      3     6      3     6        0.5        0.5        0.5\n4 d          4     8      4     8      4     8        0.5        0.5        0.5\n5 e          5    10      5    10      5    10        0.5        0.5        0.5\n6 f          6    12      6    12      6    12        0.5        0.5        0.5\n\n\nAnd voila!\nNo need to break the pipeline.\nIf you’re confused about what just happened, have a look at ?glue::glue."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kennedy Mwavu",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nDec 14, 2022\n\n\nThe power of .names in dplyr::across()\n\n\nKennedy Mwavu\n\n\n\n\n\n\nNo matching items"
  }
]