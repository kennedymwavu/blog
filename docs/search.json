[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A Hobbit's Tale",
    "section": "",
    "text": "As R Shiny applications become increasingly complex, it’s important to provide users with a smooth and intuitive user experience."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Dear Future Self,\nHere lies your footprints in the sands of time, The memories and musings of a mind. The hopes and dreams that once did shine, And the journey that you left behind.\nPast Self."
  },
  {
    "objectID": "ui-ux-r-shiny-series.html",
    "href": "ui-ux-r-shiny-series.html",
    "title": "Series: UI/UX in R Shiny",
    "section": "",
    "text": "Sorry to burst your bubble but when building applications, it’s NOT about you. It’s about your users.\nThe sole purpose of creating an application is for it to be adopted by your users.\n“ If people [users] cannot understand how to use your application, or if your application front-end does not work at all, your application is not successful no matter how innovative and incredible the computation algorithms in the back-end are. ” — Engineering Production-Grade Shiny Apps\nUsers can tell a lot about your application from the first few seconds of interacting with it. Your goal should always be to maximize user satisfaction.\nThat’s where UI/UX comes in."
  },
  {
    "objectID": "ui-ux-r-shiny-series.html#posts-in-this-series",
    "href": "ui-ux-r-shiny-series.html#posts-in-this-series",
    "title": "Series: UI/UX in R Shiny",
    "section": "Posts in this series",
    "text": "Posts in this series"
  },
  {
    "objectID": "posts/ui-ux-r-shiny-series/download-button-spinner/index.html",
    "href": "posts/ui-ux-r-shiny-series/download-button-spinner/index.html",
    "title": "Adding a Spinner to Download Buttons in R Shiny",
    "section": "",
    "text": "Here is a demo of what we will build today:"
  },
  {
    "objectID": "posts/ui-ux-r-shiny-series/download-button-spinner/index.html#introduction",
    "href": "posts/ui-ux-r-shiny-series/download-button-spinner/index.html#introduction",
    "title": "Adding a Spinner to Download Buttons in R Shiny",
    "section": "Introduction",
    "text": "Introduction\n\n\nI hope nobody is reading. But if you are, then keep this to yourself.\n\n\nMwavu\n\n\nOftentimes you have a large dataset that takes a while to download. The spinner will give your users a visual cue that the download is in progress.\nI’ll show you how to add a spinner to a download button in Shiny using a module.\nWhy a module? Because it’s a great way to encapsulate the logic of the spinner and make it reusable. You can use the same module in multiple Shiny apps."
  },
  {
    "objectID": "posts/ui-ux-r-shiny-series/download-button-spinner/index.html#creating-the-download-button-module",
    "href": "posts/ui-ux-r-shiny-series/download-button-spinner/index.html#creating-the-download-button-module",
    "title": "Adding a Spinner to Download Buttons in R Shiny",
    "section": "Creating the download button module",
    "text": "Creating the download button module\nLet’s first create a basic download button module that we can build upon.\nStarting with the UI piece, we’ll create a button that will trigger the download. We’ll also create the real download button but it will be hidden.\n#' Download button module UI\n#' @param id Module ID\n#' @return [shiny::tagList()]\nmod_dnld_ui <- function(id) {\n  ns <- shiny::NS(id)\n\n  shiny::tagList(\n    # Trigger button:\n    shiny::actionButton(\n      inputId = ns(\"actbtn\"),\n      label = htmltools::doRenderTags(\n        shiny::tags$span(\n          shiny::icon(\"download\"),\n          \"Download\"\n        )\n      )\n    ),\n\n    # Real download button:\n    shiny::downloadButton(\n      outputId = ns(\"dnld\"),\n      label = NULL,\n      style = \"visibility: hidden;\"\n    )\n  )\n}\nThe basic server piece is also as simple:\n#' Download button module server\n#' @param id Module ID\n#' @param given_data Data to download, as a reactive.\n#' @param filename Filename to use for download.\n#' @return NULL\nmod_dnld_server <- function(\n  id,\n  given_data = reactive({iris}),\n  filename = \"iris.csv\"\n) {\n  stopifnot(\n    \"`given_data` must be a reactive\" = is.reactive(given_data)\n  )\n\n  shiny::moduleServer(\n    id = id,\n    module = function(input, output, session) {\n      output$dnld <- downloadHandler(\n        filename = filename,\n        content = function(file) {\n          write.csv(given_data(), file)\n        }\n      )\n    }\n  )\n}\nIt takes in a reactive data object (given_data) and a filename for the download. We use the downloadHandler function to handle the file download. When the download button is clicked, the write.csv function is used to write the data to a CSV file with the given filename.\nNow that we have a basic download button module, we can move on to adding a spinner to the download button to improve the user experience."
  },
  {
    "objectID": "posts/ui-ux-r-shiny-series/download-button-spinner/index.html#adding-a-spinner-to-the-download-button",
    "href": "posts/ui-ux-r-shiny-series/download-button-spinner/index.html#adding-a-spinner-to-the-download-button",
    "title": "Adding a Spinner to Download Buttons in R Shiny",
    "section": "Adding a spinner to the download button",
    "text": "Adding a spinner to the download button\nSpoiler alert: the mod_dnld_ui function is done. We’ll work on the mod_dnld_server function from now on.\nIn the server module, we’ll use shiny::observeEvent to listen for clicks on the action button.\nWhen the button is clicked, we update its label to show a spinner and a message indicating that the download is in progress.\nWe then trigger a click on the real download button using shinyjs::click:\nshiny::observeEvent(input$actbtn, {\n  # update label of 'actbtn':\n  shiny::updateActionButton(\n    session = session,\n    inputId = \"actbtn\",\n    label = htmltools::doRenderTags(\n      shiny::tags$span(\n        class = \"d-flex align-items-center\",\n        shiny::tags$span(\n          class = \"spinner-border spinner-border-sm\",\n          role = \"status\",\n          `aria-hidden` = \"true\"\n        ),\n        shiny::tags$span(\n          class = \"mx-1\",\n          \"Downloading...\"\n        )\n      )\n    )\n  )\n\n  # simulate click on 'dnld' btn:\n  shinyjs::delay(\n    ms = 2 * 1e3,\n    expr = shinyjs::click(id = \"dnld\")\n  )\n})\nWe used shinyjs::delay to, well, delay the click for 2 seconds. Wanna know why?\n\n\n\nNext, we need to update the label of the action button back to its original state when the download is complete.\non.exit comes in handy here.\nFrom the documentation:\n\non.exit records the expression given as its argument as needing to be executed when the current function exits (either naturally or as the result of an error). This is useful for resetting graphical parameters or performing other cleanup actions.\n\nIn our case, we’re performing a cleanup action: updating the label of the action button back to its original state.\noutput$dnld <- downloadHandler(\n  filename = filename,\n  content = function(file) {\n    # on exit, update 'actbtn' label:\n    on.exit({\n      shiny::updateActionButton(\n        session = session,\n        inputId = \"actbtn\",\n        label = htmltools::doRenderTags(\n          shiny::tags$span(\n            shiny::icon(\"download\"),\n            \"Download\"\n          )\n        )\n      )\n    })\n\n    # write data to file:\n    write.csv(given_data(), file)\n  }\n)\nThe complete server module is as follows:\n#' Download button module server\n#' @param id Module id\n#' @param given_data Data to download, as a reactive.\n#' @param filename Filename to use for download.\n#' @return NULL\nmod_dnld_server <- function(\n    id,\n    given_data = reactive({\n      iris\n    }),\n    filename = \"iris.csv\") {\n  stopifnot(\n    \"`given_data` must be a reactive\" = is.reactive(given_data)\n  )\n\n  shiny::moduleServer(\n    id = id,\n    module = function(input, output, session) {\n      shiny::observeEvent(input$actbtn, {\n        # update label of 'actbtn':\n        shiny::updateActionButton(\n          session = session,\n          inputId = \"actbtn\",\n          label = htmltools::doRenderTags(\n            shiny::tags$span(\n              class = \"d-flex align-items-center\",\n              shiny::tags$span(\n                class = \"spinner-border spinner-border-sm\",\n                role = \"status\",\n                `aria-hidden` = \"true\"\n              ),\n              shiny::tags$span(\n                class = \"mx-1\",\n                \"Downloading...\"\n              )\n            )\n          )\n        )\n\n        # simulate click on 'dnld' btn:\n        shinyjs::delay(\n          ms = 2 * 1e3,\n          expr = shinyjs::click(id = \"dnld\")\n        )\n      })\n\n      output$dnld <- downloadHandler(\n        filename = filename,\n        content = function(file) {\n          # on exit, update 'actbtn' label:\n          on.exit({\n            shiny::updateActionButton(\n              session = session,\n              inputId = \"actbtn\",\n              label = htmltools::doRenderTags(\n                shiny::tags$span(\n                  shiny::icon(\"download\"),\n                  \"Download\"\n                )\n              )\n            )\n          })\n\n          # write data to file:\n          write.csv(given_data(), file)\n        }\n      )\n    }\n  )\n}"
  },
  {
    "objectID": "posts/ui-ux-r-shiny-series/download-button-spinner/index.html#putting-it-all-together",
    "href": "posts/ui-ux-r-shiny-series/download-button-spinner/index.html#putting-it-all-together",
    "title": "Adding a Spinner to Download Buttons in R Shiny",
    "section": "Putting it all together",
    "text": "Putting it all together\nNow that we have the UI and server modules, we can put them together in a Shiny app.\nThe app is as simple as it can get:\nui <- bslib::page(\n  theme = bslib::bs_theme(version = 5),\n  shinyjs::useShinyjs(),\n\n  shiny::tags$div(\n    class = \"bg-light\",\n\n    shiny::tags$div(\n    class = paste(\n      \"container min-vh-100\",\n      \"d-flex justify-content-center align-items-center bg-white\"\n    ),\n\n    # module UI:\n    shiny::tags$div(\n      mod_dnld_ui(\"this\")\n    )\n  )\n  )\n)\n\nserver <- function(input, output, session) {\n  # module server:\n  mod_dnld_server(\"this\")\n}\n\nshiny::shinyApp(ui, server)\nThe full code is available on this GitHub Gist."
  },
  {
    "objectID": "posts/ui-ux-r-shiny-series/defensive-programming/index.html",
    "href": "posts/ui-ux-r-shiny-series/defensive-programming/index.html",
    "title": "Defensive Programming",
    "section": "",
    "text": "Your app should never have to fail, crash or display arcane red lines of errors on the UI.\nIf it has to fail, it should do so gracefully and with dignity. You can then convince the client that it’s not a bug, it’s a feature.\nMeme?"
  },
  {
    "objectID": "posts/ui-ux-r-shiny-series/defensive-programming/index.html#your-typical-shiny-app",
    "href": "posts/ui-ux-r-shiny-series/defensive-programming/index.html#your-typical-shiny-app",
    "title": "Defensive Programming",
    "section": "Your typical shiny app",
    "text": "Your typical shiny app\n\nCase I: Error on the UI\nHere’s a very simple shiny app based on the iris dataset:\n\nThe user selects columns\nThe first 6 rows of the selected columns are displayed\n\nlibrary(shiny)\n\nui <- fluidPage(\n  titlePanel(\"First 6 rows of selected columns\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"col\",\n        label = \"Column\",\n        choices = colnames(iris),\n        selected = \"Sepal.Length\",\n        multiple = TRUE\n      )\n    ),\n    mainPanel(\n      tableOutput(\"iris\")\n    )\n  )\n)\n\nserver <- function(input, output) {\n  output$iris <- renderTable({\n    iris[, input$col, drop = FALSE] |> head()\n  })\n}\n\nshinyApp(ui, server)\nWorking fine, right?\nBut what happens if the user doesn’t select any columns?\n\nNotice that the user expected to see a table, but instead, they saw an error message. An explicit error message.\nIt might not be a big deal to you, the developer, but it’s a big deal to the user.\n\n\nCase II: App crashes"
  },
  {
    "objectID": "posts/ui-ux-r-shiny-series/defensive-programming/index.html#when-do-errors-arise",
    "href": "posts/ui-ux-r-shiny-series/defensive-programming/index.html#when-do-errors-arise",
    "title": "Defensive Programming",
    "section": "When do errors arise?",
    "text": "When do errors arise?\nMost, if not all, errors occur when you’re trying to perform a calculation or an operation on data. This can be during app startup or in response to user action.\nCommon cases are:\n\nMathematical calculations eg. +, -, *, /\nData manipulations eg. subsetting (iris[, \"Sepal.Length\"])"
  },
  {
    "objectID": "posts/ui-ux-r-shiny-series/defensive-programming/index.html#defensive-programming",
    "href": "posts/ui-ux-r-shiny-series/defensive-programming/index.html#defensive-programming",
    "title": "Defensive Programming",
    "section": "Defensive programming",
    "text": "Defensive programming\nDefensive programming is an approach to software development that focuses on anticipating and preventing potential errors, bugs, and vulnerabilities in the code.\nThe fundamental concept of this approach is to develop a program that can function correctly even in the presence of unforeseen circumstances or when users enter unexpected inputs.\nWe’ll focus on 2 key principles of defensive programming, both at the same time:\n\nValidating inputs: Checking that all input values are within expected ranges or formats, and handling unexpected input values appropriately.\nHandling errors: Catching and handling errors/exceptions in a way that allows the program to recover gracefully, without crashing or losing data\n\nThat’s where tryCatch comes in!"
  },
  {
    "objectID": "posts/ui-ux-r-shiny-series/defensive-programming/index.html#trycatch",
    "href": "posts/ui-ux-r-shiny-series/defensive-programming/index.html#trycatch",
    "title": "Defensive Programming",
    "section": "tryCatch()",
    "text": "tryCatch()\nThe basic syntax of tryCatch() is:\n\nMental model: Hey R, I have this block of code.I’m not sure if it’s flawless, but I need you to try and run it. If you encounter issues, then here’s how you should proceed depending on the reason it didn’t work:\n\nDid it throw an error? Then do <error handling>\nDid it give a warning? Then do <warning handling code>\nFinally, regardless of whether it ran successfully or failed, please do <finally block>"
  },
  {
    "objectID": "posts/ui-ux-r-shiny-series/defensive-programming/index.html#hands-on",
    "href": "posts/ui-ux-r-shiny-series/defensive-programming/index.html#hands-on",
    "title": "Defensive Programming",
    "section": "Hands-On",
    "text": "Hands-On"
  }
]