{
  "hash": "e5796d007854727e2b75735add74fa2e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Count sequential characters\"\ndescription: \"This problem has eluded me for over a year!\"\nauthor: \"Kennedy Mwavu\"\ndate: \"2024-07-20\"\ncategories: [R]\ndraft: false\n---\n\n\nThere is [this problem](https://x.com/JosiahParry/status/1646165797125931009) Josiah posted on twitter in April 12 2023:\n\n![](problem.png){alt=\"I have a string 'abcd123' and  vector of strings c('abcd124', 'abcd133', 'acbd123') and I want to count the number of shared character sequential characters. How can I do this?  preferably in a vectorized way #rstats\"}\n\nSince then, it has lingered in a corner of my mind. It is such a simple problem,\nand yet for a long time I couldn't figure out how to solve it **efficiently**\nin R.\n\n# Reprex\n\nA reprex is always a good starting point. Basically a practical explanation of\nwhat you want to achieve.\n\nWe want to create a function `count_sequential_chars()` such that:\n\n```r\nstring <- \"abcd123\"\nx <- c(\"abcd124\", \"abcd133\", \"acbd123\")\n\ncount_sequential_chars(char_vec = x, string = string)\n# [1] 6 5 1\n```\n\n```r\ncount_sequential_chars(char_vec = x, string = \"ab\")\n# [1] 2 2 1\n```\n\n```r\ncount_sequential_chars(char_vec = x, string = \"ac\")\n# [1] 1 1 2\n```\n\n```r\ncount_sequential_chars(char_vec = x, string = \"123\")\n# [1] 0 0 0\n```\n\nMain thing to note:\n\n- Matching is always done from left to right. ie. from the beginning of the \nreference string to its end.\n\n# Algorithm\n\nThinking about the problem and writing a \"solution\" in layman terms helps a lot.\nLet's use the variables we've defined in the reprex above:\n\n- `string` is the reference string\n- `x` is the character vector we're comparing against\n\n1. Get all patterns that we need to match. Take characters of the reference string\nand concatenate them from left to right, adding one at a time. Using `string`, we end up with these patterns:\n\n    - \"a\" \n    - \"ab\"\n    - \"abc\"\n    - \"abcd\"\n    - \"abcd1\"\n    - \"abcd12\"\n    - \"abcd123\"\n\n1. Now for each pattern, check whether a given item in `x` starts with that pattern. If so, give the pattern a weight of 1. Otherwise, 0. Taking the first item of `x` (\"abcd124\") as reference, we have this:\n\n    pattern             | weight\n    --------------------|----------------------:\n    \"a\"                 | 1\n    \"ab\"                | 1\n    \"abc\"               | 1\n    \"abcd\"              | 1\n    \"abcd1\"             | 1\n    \"abcd12\"            | 1\n    \"abcd123\"           | 0\n\n    : Pattern Weighting {.hover .responsive .sm}\n\n1. The number of shared sequential characters between `string` and the item is the\nsum of the weights. Again, taking the first item of `x` (\"abcd124\"), the sum\nof the weights is 6.\n\n1. Repeat steps 1 to 3 for all items of `x`.\n\n# First attempt\n\nMy first attempt was in Dec 8 2023:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsc <- \\(char_vec, str) {\n  patterns <- nchar(str) |>\n    seq_len() |>\n    sapply(\\(i) substr(x = str, start = 1, stop = i)) |>\n    sprintf(fmt = \"^%s\")\n\n  count <- rep(0, times = length(char_vec))\n  for (pattern in patterns) {\n    count <- count + grepl(pattern = pattern, x = char_vec)\n  }\n  count\n}\n```\n:::\n\n\n`csc` for `count_sequential_characters`, btw.\n\nThis solution works fine:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring <- \"abcd123\"\nx <- c(\"abcd124\", \"abcd133\", \"acbd123\")\ncsc(char_vec = x, str = string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 5 1\n```\n\n\n:::\n:::\n\n\nbut... it's too slow:\n\n```r\nsample_strings <- replicate(\n  n = 1e6,\n  expr = paste0(\n    paste0(letters[1:5] |> sample(size = 4) |> sort(), collapse = \"\"),\n    sample(x = 1:5, size = 3) |> paste0(collapse = \"\"),\n    collapse = \"\"\n  )\n)\n\nbench::mark(\n  iterations = 100,\n  csc = csc(\n    char_vec = sample_strings, \n    str = string\n  )\n)\n```\n\n```\n# A tibble: 1 × 13\n  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time\n  <bch:expr> <bch:tm> <bch:>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm>\n1 csc           627ms  638ms      1.55    87.7MB     4.71   100   304      1.07m\n# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>\n```\n\nI'm pretty sure you know that gut feeling in your stomach when... yes, you've\ndone something to the best of your knowledge but... you just know there's a better\nway to do it.\n\nThat tweet stayed in my bookmarks for so long (April 12 2023 - July 19 2024).\nI would regularly go back to the problem, but I'd always come short on the performance.\n\nTime and time again. Until yesterday.\n\n![](fail-try.jpeg){alt='The meme: Everyday, I fail. But everyday, I try again'}\n\n# Lightbulb moment\n\nThis is extremely cliché, but it's actually what happened.\n\nMostly during my workouts (2-3 pushups, nothing serious), I watch ThePrimeagen.\n\nYesterday he was reading [this article](https://www.checklyhq.com/blog/300ms-from-every-pod-startup-with-a-single-grafana-query/) about how the writer and his team saved $5k a month with a single Grafana query.\n\nHere's a link to the video:\n\n\n```{=html}\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/_QLZs0QTaZM?si=RtyS38WBhtEp3k_Q\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n```\n\n\nYou're probably not gonna watch the video anyway, so I'll just tell you: He's basically talking\nabout optimizations in software & architecture.\n\nThePrimeagen's videos always have a certain effect on my brain.\nI was in the shower when that sequential characters problem popped into my head, again.\n\nI asked myself: How many ways are there in R to check whether a string starts\nwith a certain set of characters?\n\n- `grepl()`\n- `startsWith()`\n\nThat right there, was the key.\n\n# $n^{th}$ attempt\n\nSo I re-wrote the function again. The major change was that this time I used\n`startsWith()`:\n\n```r\ncount_sequential_chars <- \\(char_vec, string) {\n  split_string <- strsplit(x = string, split = \"\")[[1]]\n\n  patterns <- character(length = length(split_string))\n  for (i in seq_along(split_string)) {\n    pattern <- split_string[seq_len(i)] |> paste(collapse = \"\")\n    patterns[i] <- pattern\n  }\n\n  res <- integer(length = length(char_vec))\n  for (pattern in patterns) {\n    res <- res + startsWith(x = char_vec, prefix = pattern)\n  }\n  res\n}\n```\n\nOf course, it works fine:\n\n```r\nstring <- \"abcd123\"\nx <- c(\"abcd124\", \"abcd133\", \"acbd123\")\ncount_sequential_chars(char_vec = x, string = string)\n# [1] 6 5 1\n```\n\nNow, let's see how it performs:\n\n```r\nbench::mark(\n  iterations = 100,\n  count_sequential_chars(\n    char_vec = sample_strings,\n    string = string\n  )\n)\n```\n\n```\n# A tibble: 1 × 13\n  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time\n  <bch:expr>   <bch:> <bch:>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm>\n1 count_seque… 78.1ms 81.8ms      11.4    57.2MB     31.3   100   274      8.76s\n# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>\n```\n\n≈ 10x faster, 35% less memory\n\nUnbelievable! \n\nI had to re-run that benchmark like 10 more times (even though\nthe benchmark itself is running 100 iterations, lol).\n\nJust like you, the question I had was: why is `startsWith()` faster than `grepl()`?\nSo I looked at the docs `?startsWith`:\n\n> `startsWith()` is equivalent to but much faster than\n>\n>   `substring(x, 1, nchar(prefix)) == prefix`  \n>\n> or also\n>\n>   `grepl(\"^<prefix>\", x)  `\n>\n> where prefix is not to contain special regular expression characters (and for grepl, x does not contain missing values, see below).\n>\n> The code has an optimized branch for the most common usage in which prefix or suffix is of length one, and is further optimized in a UTF-8 or 8-byte locale if that is an ASCII string.\n\n\nIt also turns out `grepl(..., fixed = TRUE)` would offer a similar performance but we can't use it for this problem since we strictly want to match characters at the start of a string.\n\n# Conclusion\n\n![](skill-issue.jpg){alt='The meme: Diagnosis: Skill Issue'}\n\nWe've seen it again and again, more often than not, R is usually not the problem. It's always a skill issue on the person writing the code.\n\nBut don't get me wrong...\n\nRelative to Rust, R is extremely slow & memory intensive. Just look at [the\nblog post](https://josiahparry.com/posts/2023-04-13-counting-chars/) Josiah wrote and see the Rust benchmarks. We, R users, can't relate.\n\nThis was a good challenge and I'm kinda satisfied with my current solution.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}