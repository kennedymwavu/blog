{
  "hash": "ea5892e49ca2eef6bc9f49c6f50034ff",
  "result": {
    "markdown": "---\ntitle: \"Subset every nth element from a vector\"\ndescription: \"How would you do it?\"\nauthor: \"Kennedy Mwavu\"\ndate: \"2023-04-16\"\ncategories: [R]\nimage: \"nth.svg\"\ndraft: false\n---\n\n\n## Introduction\n\nI've been using R on a daily basis (literally) precisely for 3 years 3 months 2 weeks 2 days now.\n\nIf I were to say anything about the language, it'd be what Gandalf \nsaid about Hobbits:\n\n::: {.callout-note appearance=\"simple\"}\n\nHobbits are amazing creatures. You can learn all there is to know about their ways in a month, and yet after a hundred years, they can still surprise you.\n\n--- Gandalf, LOTR\n\n:::\n\n## Problem Statement\n\nAbout a week ago I needed to subset every second element of a vector. \nLet me explain.\n\nSay you have this vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_to_hundred <- 1:100\n```\n:::\n\n\nHow do you get the values `2, 4, 6, 8, ...` from `one_to_hundred`?\n\nSimple enough, right? Right. \n\nWhat amazed me wasn't the simplicity of the question at hand, it was how even\nas a prolific user of R, the building blocks of the language sometimes slip past\nme so easily.\n\n## What I did\n\nLet's go through my thought process.\n\n### `seq()`\n\nThis was definitely the first option that came to mind:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindices <- seq(from = 2, to = 100, by = 2)\none_to_hundred[indices]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]   2   4   6   8  10  12  14  16  18  20  22  24  26  28  30  32  34  36  38\n[20]  40  42  44  46  48  50  52  54  56  58  60  62  64  66  68  70  72  74  76\n[39]  78  80  82  84  86  88  90  92  94  96  98 100\n```\n:::\n:::\n\n\nPretty good, but... Why do I have to create a vector of indices for that?\nWhy does it feel like I'm typing too much?\n\nOkay, let's try this:\n\n```r\none_to_hundred[seq(from = 2, to = 100, by = 2)]\n```\n\nHmmmhh... Less typing but still...\n\nThere must be a better solution.\n\n### Modulo Operator `%%`\n\nThe modulo operator `%%` returns the remainder of the division of one number by another. \n\nFor example, `4 %% 2` would return `0` since:\n$$\n\\frac{4}{2} = 2\\;remainder\\;0\n$$\nand `9 %% 7` would return `2` since:\n$$ \n\\frac{9}{7} = 1\\;remainder\\;2\n$$\n\nBack to our problem: I basically want all indices which are divisible by $2$ *ie.* Leave a remainder of zero. And this is easy because any number divided by $2$ can only leave a remainder of $1$ or $0$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_to_hundred %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\n [38] 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0\n [75] 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0\n```\n:::\n:::\n\n\nNote: $1$\\`s occur on odd number indices, $0$\\`s occur on even number indices.\n\nWe can then coerce the resulting vector into a logical vector and use it for subsetting.\n\nFor example, to get all odd numbers in `one_to_hundred`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_to_hundred[as.logical(one_to_hundred %% 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49\n[26] 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99\n```\n:::\n:::\n\n\nTo get the even numbers we just have to use the `NOT` operator `!`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_to_hundred[!one_to_hundred %% 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]   2   4   6   8  10  12  14  16  18  20  22  24  26  28  30  32  34  36  38\n[20]  40  42  44  46  48  50  52  54  56  58  60  62  64  66  68  70  72  74  76\n[39]  78  80  82  84  86  88  90  92  94  96  98 100\n```\n:::\n:::\n\n\nBy default, `!` coerces the numeric `one_to_hundred %% 2` to a logical vector so\nwe don't have to use `as.logical()` \n\nOkay, that's a really nice application of my freshman discrete math unit. \n\nBut is there any other (better) solution? At this point, I decided to google.\n\n## Vector recycling\n\nIf logical vectors are used for indexing in R, their values are recycled if the index vector is shorter than the vector containing the values.\n\nIt is one of my all time favorite features about R. The first time \nI learnt the concept, it was mind-blowing. \n\nThis time round, it swept me off  my feet completely.\n\nThe solution was as simple as this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_to_hundred[c(FALSE, TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]   2   4   6   8  10  12  14  16  18  20  22  24  26  28  30  32  34  36  38\n[20]  40  42  44  46  48  50  52  54  56  58  60  62  64  66  68  70  72  74  76\n[39]  78  80  82  84  86  88  90  92  94  96  98 100\n```\n:::\n:::\n\n\nTell me that isn't elegant! \n\nThat's one of the best answers on StackOverflow as far as I'm concerned.\n\n- Short.\nIn most cases short never equals good performance but this is one of the few\ncases where what's advertised is what's delivered.\n\n- Simple.\nIt's very easy to understand. Straightforward.\n\n- Clean.\nIt's not obfuscated. \n\nIt's better in every way compared to my initial trials. It was posted by the user `Sven Hohenstein`. [Link to the answer.](https://stackoverflow.com/a/13462110/16246909)\n\n## Generalization\n\nNow that we have the best solution (as far as we know), let's generalize it. \n\n### $i^{th}$ element\n\nWhat if you wanted to subset every 9th element? Repeat `TRUE` & `FALSE` the required number of times:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset every 9th element:\none_to_hundred[c(rep(FALSE, times = 8), TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  9 18 27 36 45 54 63 72 81 90 99\n```\n:::\n:::\n\nWe repeat `FALSE` $8$ times because we want every $9$th index to be retrieved.\n\nTaking $9$ as our `i`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 9\none_to_hundred[c(rep(FALSE, times = i - 1), TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  9 18 27 36 45 54 63 72 81 90 99\n```\n:::\n:::\n\n\n### $(i + n)^{th}$ element\n\nExtending the above logic, let's assume `i` is $9$ and `n` is $10$. So it's like saying we want to subset every $(9 + 10)^{th} = 19^{th}$ element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 9\nn <- 10\n# So we repeat FALSE \"i + n - 1\" times:\none_to_hundred[c(rep(FALSE, times = i + n - 1), TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19 38 57 76 95\n```\n:::\n:::\n\n\n\n## Conclusion\n\n![](keep-it-simple-stupid.jpg)\n\nTill next time, avoid complicating stuff.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}