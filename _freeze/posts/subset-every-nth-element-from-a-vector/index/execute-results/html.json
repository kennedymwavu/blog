{
  "hash": "7b2aef0abe791b470bed1b7387d1ee64",
  "result": {
    "markdown": "---\ntitle: \"Subset every nth element from a vector\"\ndescription: \"How would you do it?\"\nauthor: \"Kennedy Mwavu\"\ndate: \"2023-04-16\"\ncategories: [R]\nimage: \"nth.svg\"\ndraft: false\n---\n\n\n## Introduction\n\nI've been using R on a daily basis (literally) precisely for 3 years 3 months 2 weeks 2 days now.\n\nIf I were to say anything about the language, it'd be what Gandalf \nsaid about Hobbits:\n\n![](gandalf.webp)\n\n::: {.callout-note appearance=\"simple\"}\n\nHobbits are amazing creatures. You can learn all there is to know about their ways in a month, and yet after a hundred years, they can still surprise you.\n\n--- Gandalf, LOTR\n\n:::\n\n## Problem Statement\n\nAbout a week ago I needed to subset every second element of a vector. \nLet me explain.\n\nTake a look at `letters`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletters\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n```\n:::\n:::\n\n\nHow do you get the elements \"b\", \"d\", \"f\", \"h\", \"j\", ... ie. values at the indices `2, 4, 6, 8, ...`?\n\nSimple enough, right? Right. \n\nWhat amazed me wasn't the simplicity of the question at hand, it was how even\nas a prolific user of R, the building blocks of the language sometimes slip past\nme so easily.\n\n## What I did\n\nLet's go through my thought process.\n\n### `seq()`\n\nThis was definitely the first option that came to mind:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindices <- seq(from = 2, to = length(letters), by = 2)\nletters[indices]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"b\" \"d\" \"f\" \"h\" \"j\" \"l\" \"n\" \"p\" \"r\" \"t\" \"v\" \"x\" \"z\"\n```\n:::\n:::\n\n\nPretty good, but... \n\nThere must be a better solution.\n\n### Modulo Operator `%%`\n\nThe modulo operator `%%` returns the remainder of the division of one number by another. \n\nFor example, `4 %% 2` would return `0` since:\n$$\n\\frac{4}{2} = 2\\;remainder\\;0\n$$\nand `9 %% 7` would return `2` since:\n$$ \n\\frac{9}{7} = 1\\;remainder\\;2\n$$\n\nBack to our problem: I basically want all indices which are divisible by $2$ *ie.* Leave a remainder of zero. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nindices <- !seq_along(letters) %% 2\nletters[indices]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"b\" \"d\" \"f\" \"h\" \"j\" \"l\" \"n\" \"p\" \"r\" \"t\" \"v\" \"x\" \"z\"\n```\n:::\n:::\n\n\nThat works but... It's quite obfuscated for such a simple problem.\n\n![](trynna-explain.jpg)\n\nThere's only one way to know if there's an easier solution: Google.\n\n## Vector recycling\n\nIf logical vectors are used for indexing in R, their values are recycled if the index vector is shorter than the vector containing the values.\n\nIt is one of my all time favorite features about R. The first time \nI learnt the concept, it was mind-blowing. \n\nThis time round, it swept me off  my feet completely.\n\nThe solution was as simple as this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletters[c(FALSE, TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"b\" \"d\" \"f\" \"h\" \"j\" \"l\" \"n\" \"p\" \"r\" \"t\" \"v\" \"x\" \"z\"\n```\n:::\n:::\n\n\nTell me that isn't elegant! \n\nThat's one of the best answers on StackOverflow as far as I'm concerned.\n\n- Short.\nIn most cases short never equals good performance but this is one of the few\ncases where what's advertised is what's delivered.\n\n- Simple.\nIt's very easy to understand. Straightforward.\n\n- Clean.\nIt's not obfuscated. \n\nIt's better in every way compared to my initial trials. It was posted by the user `Sven Hohenstein`. [Link to the answer.](https://stackoverflow.com/a/13462110/16246909)\n\n## Generalization\n\nNow that we have the best solution (as far as we know), let's generalize it. \n\n### $i^{th}$ element\n\nWhat if you wanted to subset every 9th element? Repeat `TRUE` & `FALSE` the required number of times:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset every 9th element:\nletters[c(rep(FALSE, times = 8), TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"i\" \"r\"\n```\n:::\n:::\n\nWe repeat `FALSE` $8$ times because we want every $9$th index to be retrieved.\n\nTaking $9$ as our `i`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 9\nletters[c(rep(FALSE, times = i - 1), TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"i\" \"r\"\n```\n:::\n:::\n\n\n### $(i + n)^{th}$ element\n\nExtending the above logic, let's assume `i` is $9$ and `n` is $10$. So it's like saying we want to subset every $(9 + 10)^{th} = 19^{th}$ element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 9\nn <- 10\n# So we repeat FALSE \"i + n - 1\" times:\nletters[c(rep(FALSE, times = i + n - 1), TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"s\"\n```\n:::\n:::\n\n\n\n## Conclusion\n\n![](keep-it-simple-stupid.jpg)\n\nTill next time, avoid complicating stuff.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}