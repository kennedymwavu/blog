{
  "hash": "291c4f1efcdf2206c2a85cea9ea1c3c2",
  "result": {
    "markdown": "---\ntitle: \"The power of .names in dplyr::across()\"\nauthor: \"Kennedy Mwavu\"\ndate: \"2022-12-14\"\ncategories: [rlang, dplyr]\nimage: \"across.jpg\"\n---\n\n\n![](across.jpg)\n\n### Introduction\n\nMy project manager is a die-hard fan of the tidyverse. I go to the office once a week, and last Friday was one of those days.\n\nHe comes up to me and says:\n\n\"Good afternoon Mwavu, you know how much I'm into the tidyverse and piping. But today, it seems, I have to break my pipeline. Come have a look.\"\n\n![](broken-pipe.webp)\n\n### Problem statement\n\n\"Say I have this tibble:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprem_sum <- tibble::tibble(\n  id = head(letters), \n  prem_a = seq_along(id), \n  sum_a = seq_along(id) * 2, \n  prem_b = prem_a, \n  sum_b = sum_a, \n  prem_c = prem_a, \n  sum_c = sum_a\n)\n\nprint(prem_sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n  id    prem_a sum_a prem_b sum_b prem_c sum_c\n  <chr>  <int> <dbl>  <int> <dbl>  <int> <dbl>\n1 a          1     2      1     2      1     2\n2 b          2     4      2     4      2     4\n3 c          3     6      3     6      3     6\n4 d          4     8      4     8      4     8\n5 e          5    10      5    10      5    10\n6 f          6    12      6    12      6    12\n```\n:::\n:::\n\n\nI want to divide the corresponding 'prem' and 'sum' columns, ie. `prem_a / sum_a`, `prem_b / sum_b`, `prem_c / sum_c` etc.\n\nFrom that, new columns should be created with the name format of `prem_sum_a`, `prem_sum_b`, `prem_sum_c` etc.\n\nHow do I do that without having to create an intermediate object to hold the result of the calculations and then having to patch it back to the original tibble?\n\nIn other words, how do I not break my pipeline? Also, I have around 20 such columns.\"\n\n### Have you tried across()?\n\n\"Yes I have but it overwrites my previous columns. Look at this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprem_sum |> \n  dplyr::mutate(\n    dplyr::across(\n      .cols = dplyr::starts_with('prem_')\n    ) / \n      dplyr::across(\n        .cols = dplyr::starts_with('sum_')\n      )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n  id    prem_a sum_a prem_b sum_b prem_c sum_c\n  <chr>  <dbl> <dbl>  <dbl> <dbl>  <dbl> <dbl>\n1 a        0.5     2    0.5     2    0.5     2\n2 b        0.5     4    0.5     4    0.5     4\n3 c        0.5     6    0.5     6    0.5     6\n4 d        0.5     8    0.5     8    0.5     8\n5 e        0.5    10    0.5    10    0.5    10\n6 f        0.5    12    0.5    12    0.5    12\n```\n:::\n:::\n\n\nAll `prem_*` columns are overwritten, and I don't want that to happen.\"\n\n### What about the .names argument to across()?\n\n\"No, not yet.\"\n\nOkay, let's give it a shot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprem_sum |> \n  dplyr::mutate(\n    dplyr::across(\n      .cols = dplyr::starts_with('prem_'), \n      .names = 'PREMSUM_{.col}'\n    ) / \n      dplyr::across(\n        .cols = dplyr::starts_with('sum_')\n      )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n  id    prem_a sum_a prem_b sum_b prem_c sum_c PREMSUM_prem_a PREMSUM_…¹ PREMS…²\n  <chr>  <int> <dbl>  <int> <dbl>  <int> <dbl>          <dbl>      <dbl>   <dbl>\n1 a          1     2      1     2      1     2            0.5        0.5     0.5\n2 b          2     4      2     4      2     4            0.5        0.5     0.5\n3 c          3     6      3     6      3     6            0.5        0.5     0.5\n4 d          4     8      4     8      4     8            0.5        0.5     0.5\n5 e          5    10      5    10      5    10            0.5        0.5     0.5\n6 f          6    12      6    12      6    12            0.5        0.5     0.5\n# … with abbreviated variable names ¹​PREMSUM_prem_b, ²​PREMSUM_prem_c\n```\n:::\n:::\n\n\n\"Ahaa, that's nice! I can now rename the columns starting with `PREMSUM` to whatever I need. I was kinda hoping for something better and straightforward though.\"\n\nThat's the best I can think of now.\n\n### Really?!\n\nA week down the line and today I found myself messing around with `across()`. I remembered my PM's question and his words \"... I was kinda hoping for something better and straightforward though.\"\n\nDoes he have to `dplyr::rename()`?\n\nFirst, let's have a look at the documentation of `.names` arg in `across()`:\n\n> A glue specification that describes how to name the output columns. This can use {.col} to stand for the selected column name, and {.fn} to stand for the name of the function being applied. The default (NULL) is equivalent to \"{.col}\" for the single function case and \"{.col}_{.fn}\" for the case where a list is used for .fns.\n\nYou mean `{.col}` can only be used for the current column which is being computed on? Then there surely isn't a better way.\n\nWait... Do me a favor and print out `{.col}`, just curious.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprem_sum |> \n  dplyr::mutate(\n    dplyr::across(\n      .cols = dplyr::starts_with('prem_'), \n      .names = 'PREMSUM_{print(.col)}'\n    ) / \n      dplyr::across(\n        .cols = dplyr::starts_with('sum_')\n      )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"prem_a\" \"prem_b\" \"prem_c\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n  id    prem_a sum_a prem_b sum_b prem_c sum_c PREMSUM_prem_a PREMSUM_…¹ PREMS…²\n  <chr>  <int> <dbl>  <int> <dbl>  <int> <dbl>          <dbl>      <dbl>   <dbl>\n1 a          1     2      1     2      1     2            0.5        0.5     0.5\n2 b          2     4      2     4      2     4            0.5        0.5     0.5\n3 c          3     6      3     6      3     6            0.5        0.5     0.5\n4 d          4     8      4     8      4     8            0.5        0.5     0.5\n5 e          5    10      5    10      5    10            0.5        0.5     0.5\n6 f          6    12      6    12      6    12            0.5        0.5     0.5\n# … with abbreviated variable names ¹​PREMSUM_prem_b, ²​PREMSUM_prem_c\n```\n:::\n:::\n\n\nWhoa!\n\n`{.col}` is a vector of all the selected column names, not just the current one.\n\nThat means I can manipulate the .names arg even further.\n\nIt can get easier.\n\n### Better, huh?\n\nLet's start small. Say I have this vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- paste0('prem_', letters[1:3])\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"prem_a\" \"prem_b\" \"prem_c\"\n```\n:::\n:::\n\n\nAll I need is to add 'sum' between 'prem' and the suffixes, separated by an underscore. I can use `substr()` for that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste0(\n  'prem_sum', \n  substr(x = x, start = nchar('prem_'), stop = nchar(x))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"prem_sum_a\" \"prem_sum_b\" \"prem_sum_c\"\n```\n:::\n:::\n\n\nCircling back, replace `x` with `.col` in `substr()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprem_sum |> \n  dplyr::mutate(\n    dplyr::across(\n      .cols = dplyr::starts_with('prem_'), \n      .names = \"{paste0(\n        'prem_sum', \n        substr(x = .col, start = nchar('prem_'), stop = nchar(.col))\n      )}\"\n    ) / \n      dplyr::across(\n        .cols = dplyr::starts_with('sum_')\n      )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n  id    prem_a sum_a prem_b sum_b prem_c sum_c prem_sum_a prem_sum_b prem_sum_c\n  <chr>  <int> <dbl>  <int> <dbl>  <int> <dbl>      <dbl>      <dbl>      <dbl>\n1 a          1     2      1     2      1     2        0.5        0.5        0.5\n2 b          2     4      2     4      2     4        0.5        0.5        0.5\n3 c          3     6      3     6      3     6        0.5        0.5        0.5\n4 d          4     8      4     8      4     8        0.5        0.5        0.5\n5 e          5    10      5    10      5    10        0.5        0.5        0.5\n6 f          6    12      6    12      6    12        0.5        0.5        0.5\n```\n:::\n:::\n\n\nAnd voila!\n\nNo need to break the pipeline.\n\nIf you're confused about what just happened, have a look at `?glue::glue`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}